#include <Windows.h>
#include <Uxtheme.h>
#include "fixregistry.h"
#include <Vssym32.h>


#pragma comment(lib, "uxtheme.lib")
#pragma comment(lib, "Comctl32.lib")
#define MENU_REMOVE_CRITICAL_PROCESS 1
#define BUTTON_ID_OFFSET 100
#pragma comment(linker,"\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Custom button procedure for drawing the button
LRESULT CALLBACK ButtonProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    switch (uMsg)
    {
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // Set the button properties
        SetBkColor(hdc, RGB(0, 0, 0)); // White text color
        SetTextColor(hdc, RGB(255, 255, 255)); // Black background color/ Black background color

        // Get the button text
        wchar_t buttonText[256];
        GetWindowTextW(hwnd, buttonText, sizeof(buttonText) / sizeof(buttonText[0]));

        // Draw the button text
        RECT rect;
        GetClientRect(hwnd, &rect);
        DrawTextW(hdc, buttonText, -1, &rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        EndPaint(hwnd, &ps);
    }
    return 0;

    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, ButtonProc, uIdSubclass);
        break;

    default:
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}
BOOL IsProcessElevated(VOID) {
    BOOL IsElevated = FALSE;
    HANDLE hToken = NULL;
    TOKEN_ELEVATION elevation;
    DWORD dwSize;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        if (hToken) {
            CloseHandle(hToken);
            hToken = NULL;
            return FALSE;
        }
    }


    if (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize)) {
        if (hToken) {
            CloseHandle(hToken);
            hToken = NULL;
            return FALSE;
        }
    }

    return elevation.TokenIsElevated;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    if (!IsProcessElevated()) {
        wchar_t modulePath[MAX_PATH];
        if (GetModuleFileName(NULL, modulePath, MAX_PATH) == 0)
        {
            // Error handling: Failed to get the module path
            return false;
        }

        SHELLEXECUTEINFO shellExecuteInfo = { sizeof(SHELLEXECUTEINFO) };
        shellExecuteInfo.lpVerb = L"runas";  // Run the program as administrator
        shellExecuteInfo.lpFile = modulePath;
        shellExecuteInfo.nShow = SW_SHOWNORMAL;

        if (!ShellExecuteEx(&shellExecuteInfo))
        {
            MessageBox(NULL, L"Please Run This Program As An Admin", NULL, MB_OK | MB_ICONSTOP);
            // Error handling: Failed to elevate the program
            return -1;
        }
        return -1;
    }

    const TCHAR szClassName[] = TEXT("FixWindows");

    WNDCLASS wc = { 0 };
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    //wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.hbrBackground = CreateSolidBrush(RGB(30, 30, 30));
    wc.lpszClassName = szClassName;

    if (!RegisterClass(&wc))
    {
        return 1;
    }

    HWND hwnd = CreateWindowEx(0, szClassName, TEXT("FixWindows"), WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 650, NULL, NULL, hInstance, NULL);

    if (!hwnd)
    {
        return 2;
    }
    
    // Create the menu
    HMENU hMenu = CreateMenu();
    HMENU hSubMenu = CreatePopupMenu();
    AppendMenu(hSubMenu, MF_STRING, MENU_REMOVE_CRITICAL_PROCESS, L"Remove Critical Process Property For A Process");
    AppendMenu(hMenu, MF_POPUP, (UINT_PTR)hSubMenu, L"Menu");


    // Set the menu for the main window
    SetMenu(hwnd, hMenu);
    // Enable visual styles
    INITCOMMONCONTROLSEX icex;
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_STANDARD_CLASSES;
    InitCommonControlsEx(&icex);

    // Create the buttons
    const int numButtons = 11;
    const wchar_t* buttonText[] = {
        L"Launch",
        L"Activate(#1)",
        L"Activate(#2)",
        L"Activate(#3)",
        L"Activate(#4)",
        L"Activate(#5)",
        L"Activate(#6)",
        L"Activate(#7)",
        L"Activate(#8)",
        L"Activate(#9)",
        L"Activate(#10)",
    };

    for (int i = 0; i < numButtons; ++i)
    {
        // Create the button
        HWND hButton = CreateWindowW(TEXT("BUTTON"), buttonText[i], WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            600, 20 + (50 * i), 120, 40, hwnd, (HMENU)(BUTTON_ID_OFFSET + i), NULL, NULL);

        // Set the font for the button
        HFONT hButtonFont = CreateFont(16, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, TEXT("Arial"));
        HFONT hFont = CreateFont(20, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, TEXT("Arial"));
        SendMessage(hButton, WM_SETFONT, (WPARAM)hFont, TRUE);

        // Subclass the button to perform custom drawing
        //SetWindowSubclass(hButton, ButtonProc, 0, 0);
    }

    ShowWindow(hwnd, nCmdShow);

    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (hInputDialog == NULL || !IsDialogMessage(hInputDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return msg.wParam;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    const wchar_t* command = nullptr;
    static HWND hEdit;
    static HWND hScroll;
    const int numButtons = 11;
    const wchar_t* buttoncomText[] = {
        L"Automatic Repair\nScans And Fixes Everything",
        L"Enable Registry(#1)",
        L"Enable CMD(#2)",
        L"Enable Taskmgr(#3)",
        L"Enable UAC(#3)",
        L"Enable Themes And Colour Settings(#5)",
        L"Enable Run Menu(#6)",
        L"Enable Windows Key(#7)",
        L"Reset Shell Key(#8)",
        L"Reset Userinit key and reset all EXE and TXT stuff(#9)",
        L"Remove Keyboard Restrictions and Swap Mouse Key If Flipped(#10)",
        // Add more button names here
    };
    switch (uMsg)
    {
    case WM_CREATE:
    {
        // Enable visual styles
        INITCOMMONCONTROLSEX icex;
        icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icex.dwICC = ICC_STANDARD_CLASSES;
        InitCommonControlsEx(&icex);

        for (int i = 0; i < numButtons; ++i)
        {
            // Create the static text control
            wchar_t buttonInfo[256];

            swprintf_s(buttonInfo, sizeof(buttonInfo) / sizeof(buttonInfo[0]), L"%s", buttoncomText[i]);
            HWND hText = CreateWindowW(TEXT("STATIC"), buttonInfo,
                WS_CHILD | WS_VISIBLE | SS_LEFT | WS_CLIPSIBLINGS,
                30, 20 + (50 * i), 300, 50, hwnd, NULL, NULL, NULL);

            // Set the font for the static text control
            HFONT hFont = CreateFont(20, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, TEXT("Arial"));
            SendMessage(hText, WM_SETFONT, (WPARAM)hFont, TRUE);

            // Set the background color of the static text control
            SetWindowLongPtr(hText, GWL_EXSTYLE, GetWindowLongPtr(hText, GWL_EXSTYLE) | WS_EX_TRANSPARENT);
        }
    }
    break;
    case WM_CTLCOLORSTATIC:
    {
        HDC hdcStatic = (HDC)wParam;
        SetTextColor(hdcStatic, RGB(255, 255, 255)); // White text color
        SetBkMode(hdcStatic, TRANSPARENT); // Set background mode to transparent
        return (LRESULT)GetStockObject(NULL_BRUSH); // Return a null brush to paint the background
    }
    break;
    case WM_COMMAND:
    {
        int wmId = LOWORD(wParam);
        switch (wmId)
        {
        case MENU_REMOVE_CRITICAL_PROCESS:
        {
            // Handle menu item click
            if (hInputDialog == NULL) // Check if the input dialog is not already open
                ShowInputDialog();
            break;
        }
        default:
        {
            // Check if the button click event occurred
            if (wmId >= BUTTON_ID_OFFSET && wmId < BUTTON_ID_OFFSET + numButtons)
            {
                int buttonIndex = wmId - BUTTON_ID_OFFSET;

                // Call the corresponding function based on the button index
                switch (buttonIndex)
                {
                case 0:
                    automatic();
                    break;
                case 1:
                    enableRegistryEditor();
                    break;
                case 2:
                    enableCMD();
                    break;
                case 3:
                    enableTaskManager();
                    break;
                case 4:
                    enableUAC();
                    break;
                case 5:
                    enableColorSettings();
                    enableThemes();
                    break;
                case 6:
                    enableRunMenu();
                    break;
                case 7:
                    enableWindowsKey();
                    break;
                case 8:
                    resetShellKey();
                    break;
                case 9:
                    MessageBoxA(NULL, "Here Comes Nothing..! :)", NULL, MB_OK | MB_ICONASTERISK);
                    resetUserinitKey();
                    resetExeIcons();
                    resetTxtIcons();
                    resetRunAsCommandDefault();
                    resetExeCommandDefault();
                    break;
                case 10:
                    removeKeyboardRestrictions();
                    resetPrimaryMouseButton();
                    break;
                default:
                    break;
                }
            }
            break;
        }
        }
        break;
    }
    case WM_CLOSE:
    {
        DestroyWindow(hwnd);
        break;
    }
    case WM_DESTROY:
    {
        PostQuitMessage(0);
        break;
    }
    default:
    {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    }

    return 0;
}